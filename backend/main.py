
from fastapi import FastAPI, HTTPException, Body
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Optional
import datetime
import traceback
import random
import os
import csv
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from database import db
from models import Pilot, Flight, Disruption, CostModel, SimulationRequest, HealRequest, CrewRestRequest, CrewCostRequest

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

LATEST_AGENT_LOGS = []

# --- Email Helper ---

def send_delay_email(flight_number, origin, dest, delay_minutes, reason):
    # Credentials (preserved)
    sender_email = "demorugved2@outlook.com" 
    sender_password = "lmhahkmedknicokl" 
    receiver_email = "kadurugved0@gmail.com"
    
    if "YOUR_OUTLOOK" in sender_email:
        return False

    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = receiver_email
    msg['Subject'] = f"AeroResilience Alert: Flight {flight_number} Delayed"
    
    body = f"""
    <html>
      <body>
        <h2 style="color: #ef4444;">Flight Delay Alert</h2>
        <p><strong>Flight:</strong> {flight_number} ({origin} &rarr; {dest})</p>
        <p><strong>Delay Duration:</strong> {delay_minutes} minutes</p>
        <p><strong>Reason:</strong> {reason}</p>
        <hr>
        <p><em>Generated by AeroResilience AI Agent</em></p>
      </body>
    </html>
    """
    msg.attach(MIMEText(body, 'html'))
    
    try:
        server = smtplib.SMTP('smtp.office365.com', 587)
        server.starttls()
        server.login(sender_email, sender_password)
        text = msg.as_string()
        server.sendmail(sender_email, receiver_email, text)
        server.quit()
        
        global LATEST_AGENT_LOGS
        success_msg = f"NOTIFICATION: Sent email alert to {receiver_email}."
        if success_msg not in LATEST_AGENT_LOGS: LATEST_AGENT_LOGS.append(success_msg)
        return True
        
    except smtplib.SMTPAuthenticationError:
        sim_msg = f"NOTIFICATION: SMTP Auth Blocked (App Password Reqd). Simulating email to {receiver_email}."
        if sim_msg not in LATEST_AGENT_LOGS: LATEST_AGENT_LOGS.append(sim_msg)
        return False
        
    except Exception as e:
        err_msg = f"NOTIFICATION: Email failed ({str(e)[:20]}...). Simulating notification."
        if err_msg not in LATEST_AGENT_LOGS: LATEST_AGENT_LOGS.append(err_msg)
        return False

# --- Business Logic Helpers ---

async def calculate_impact(flight_id: str):
    flight = await db.flights.find_one({"_id": flight_id})
    if not flight: return
    
    pilot = await db.pilots.find_one({"_id": flight['assignedPilotId']})
    if not pilot: return
    
    if not flight.get('flightDurationMinutes'): flight['flightDurationMinutes'] = 120
    projected_duty_at_landing = pilot['currentDutyMinutes'] + flight['flightDurationMinutes'] + flight.get('delayMinutes', 0)
    
    is_violation = projected_duty_at_landing > pilot['maxLegalDutyMinutes']
    
    update_data = {
        "predictedFailure": is_violation,
        "predictedFailureProbability": 0.95 if is_violation else 0.1,
        "predictedFailureReason": "Maximum FDTL Exceeded" if is_violation else None,
        "boardingAllowed": not is_violation
    }
    
    if pilot['status'] == 'SICK':
        is_violation = True
        update_data["predictedFailure"] = True
        update_data["predictedFailureReason"] = "Pilot Incapacitated (Sick)"
        update_data["boardingAllowed"] = False
    
    if is_violation:
        update_data["status"] = "CRITICAL"
        log_msg = f"PREDICTION: Flight {flight_id} will fail. Reason: {update_data['predictedFailureReason']}"
        if log_msg not in LATEST_AGENT_LOGS: LATEST_AGENT_LOGS.append(log_msg)
    
    await db.flights.update_one({"_id": flight_id}, {"$set": update_data})
    
    return is_violation

# --- New Crew Management Endpoints ---

@app.post("/crew/update_rest")
async def update_rest(req: CrewRestRequest):
    timestamp = datetime.datetime.now()
    await db.pilots.update_one(
        {"_id": req.pilot_id},
        {"$set": {
            "currentDutyMinutes": 0,
            "fatigue_score": 0.0,
            "status": "AVAILABLE",
            "last_rest_period_end": timestamp,
            "remainingDutyMinutes": 480
        }}
    )
    LATEST_AGENT_LOGS.append(f"CREW-OPS: Granted 24h Rest to {req.pilot_id}.")
    return {"status": "REST_ALLOCATED"}

@app.post("/crew/calculate_cost")
async def calculate_crew_cost(req: CrewCostRequest):
    pilot = await db.pilots.find_one({"_id": req.pilot_id})
    if not pilot: return {"error": "Pilot Not Found"}

    base_rate_per_min = 1000 / 60 
    ot_rate_per_min = pilot.get('overtime_rate_per_hour', 5000) / 60
    
    current_weekly = pilot.get('weekly_flight_minutes', 0)
    add_mins = req.additional_minutes
    
    cost = 0
    if current_weekly > 2400: # Over 40 hours
        cost = add_mins * ot_rate_per_min
    elif current_weekly + add_mins > 2400:
        normal_mins = 2400 - current_weekly
        ot_mins = (current_weekly + add_mins) - 2400
        cost = (normal_mins * base_rate_per_min) + (ot_mins * ot_rate_per_min)
    else:
        cost = add_mins * base_rate_per_min
        
    projected_fatigue = pilot.get('fatigue_score', 0) + (add_mins / 600)
    if projected_fatigue > 1.0: projected_fatigue = 1.0
    
    return {
        "cost": round(cost, 2),
        "projected_fatigue": round(projected_fatigue, 2),
        "is_overtime": (current_weekly + add_mins) > 2400
    }

# --- Endpoints ---

@app.get("/")
def read_root(): return {"message": "AeroResilience 2.0 Backend Online"}

@app.get("/seed")
async def seed_data():
    await db.flights.drop()
    await db.pilots.drop() 
    await db.pilot_readiness.drop()
    await db.disruptions.drop()
    await db.cost_model.drop()
    
    await db.cost_model.insert_one(CostModel().dict())
    
    base_path = "e:\\ARes\\backend"
    pilot_csv_path = os.path.join(base_path, "pilot.csv")
    
    flights = []
    pilots = []
    existing_pilots = set()
    now = datetime.datetime.now()
    forced_routes = [("DEL", "BOM"), ("BOM", "BLR"), ("BLR", "DEL"), ("MAA", "CCU"), ("CCU", "DEL")]
    route_idx = 0

    if os.path.exists(pilot_csv_path):
        with open(pilot_csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for i, row in enumerate(reader):
                f_id = row.get('Flight_ID', '').strip()
                if not f_id: continue

                origin = row.get('Origin', 'DEL')
                dest = row.get('Destination', 'BOM')
                if i % 2 == 0:
                    r = forced_routes[route_idx % len(forced_routes)]
                    origin, dest = r
                    route_idx += 1

                p_id = row.get('Pilot_ID', f"P-{f_id}")
                if p_id not in existing_pilots:
                    rest = float(row.get('Rest_Hours', 12))
                    fatigue = float(row.get('Fatigue_Score', 0) or 0)
                    if fatigue > 1.0: fatigue = fatigue / 100.0
                    
                    duty_used = random.randint(300, 450) if rest < 10 else random.randint(0, 200)
                    weekly_mins = random.randint(1800, 2600) # 30-43 hours random

                    pilot_doc = {
                        "_id": p_id,
                        "name": row.get('Name', f"Pilot {p_id}"),
                        "base": origin,
                        "currentDutyMinutes": duty_used,
                        "maxLegalDutyMinutes": 480,
                        "remainingDutyMinutes": 480 - duty_used,
                        "fatigue_score": fatigue,
                        "status": "AVAILABLE",
                        "aircraftTypeQualified": [row.get('Aircraft_Type', 'A320')],
                        "lastUpdated": now,
                        "weekly_flight_minutes": weekly_mins,
                        "overtime_rate_per_hour": random.choice([5000, 7500, 10000]),
                        "last_rest_period_end": now - datetime.timedelta(hours=rest)
                    }
                    pilots.append(pilot_doc)
                    existing_pilots.add(p_id)

                offset_mins = random.randint(30, 400) 
                dur_mins = 120
                
                flight_doc = {
                    "_id": f_id,
                    "flightNumber": f_id,
                    "origin": origin,
                    "destination": dest,
                    "scheduledDeparture": now + datetime.timedelta(minutes=offset_mins),
                    "scheduledArrival": now + datetime.timedelta(minutes=offset_mins + dur_mins),
                    "flightDurationMinutes": dur_mins,
                    "status": "ON_TIME",
                    "delayMinutes": 0,
                    "delayReason": None,
                    "assignedPilotId": p_id,
                    "boardingAllowed": True,
                    "predictedFailure": False,
                    "decisionMode": "AUTO",
                    "Pilot_Name": row.get('Name', f"Pilot {p_id}"),
                    "Flight_Duration": f"2h 00m"
                }
                flights.append(flight_doc)

    if pilots: await db.pilots.insert_many(pilots)
    if flights: await db.flights.insert_many(flights)
    global LATEST_AGENT_LOGS
    LATEST_AGENT_LOGS = ["LOG: Database Seeded."]
    return {"status": "SEEDED"}

@app.get("/data")
async def get_data():
    flights = await db.flights.find().to_list(100)
    pilots = await db.pilots.find().to_list(100)
    return {"flights": flights, "pilot_readiness": pilots, "agent_logs": LATEST_AGENT_LOGS}

@app.get("/status")
async def check_status():
    critical = await db.flights.count_documents({"status": "CRITICAL"})
    return {"status": "CRITICAL" if critical > 0 else "VALID"}

@app.post("/simulate")
async def simulate(req: SimulationRequest):
    delay_map = {"Fog": 240, "Thunderstorm": 120, "Technical": 180, "ATC": 90, "Sickness": 0}
    delay = delay_map.get(req.subType, 180)
    reason = f"Heavy {req.subType or req.type}"
    target_flight_id = req.flight_id

    if req.type == "CREW" or req.subType == "Sickness":
        if target_flight_id:
            flight = await db.flights.find_one({"_id": target_flight_id})
            if flight and flight.get('assignedPilotId'):
                 await db.pilots.update_one({"_id": flight['assignedPilotId']}, {"$set": {"status": "SICK", "fatigue_score": 1.0}})
                 await db.flights.update_one({"_id": target_flight_id}, {
                    "$set": {"status": "CRITICAL", "predictedFailure": True, "predictedFailureReason": "Pilot Incapacitated (Sick)"}
                })
                 LATEST_AGENT_LOGS.append(f"INJECT: Pilot SICK on {target_flight_id}.")
                 return {"status": "SIMULATED_SICKNESS"}
        else:
             return {"status": "ERROR_NEED_FLIGHT_ID"}

    if req.flight_id:
        flight_doc = await db.flights.find_one({"_id": req.flight_id})
        await db.flights.update_one({"_id": req.flight_id}, {"$set": {"delayMinutes": delay, "delayReason": reason, "status": "DELAYED"}})
        LATEST_AGENT_LOGS.append(f"INJECT: {reason} on Flight {req.flight_id}.")
        if flight_doc: send_delay_email(req.flight_id, flight_doc['origin'], flight_doc['destination'], delay, reason)
        await calculate_impact(req.flight_id)
    else:
        await db.flights.update_many({"origin": req.airport}, {"$set": {"delayMinutes": delay, "delayReason": reason, "status": "DELAYED"}})
        LATEST_AGENT_LOGS.append(f"INJECT: {reason} at {req.airport}. Ops Impacted.")
        affected = await db.flights.find({"origin": req.airport}).to_list(100)
        for f in affected: 
            send_delay_email(f['_id'], f['origin'], f['destination'], delay, reason)
            await calculate_impact(f["_id"])
            
    return {"status": "SIMULATED"}

@app.post("/heal")
async def heal(req: HealRequest):
    flight = await db.flights.find_one({"status": "CRITICAL"})
    if not flight: return {"status": "NO_ACTION"}
    
    options = []
    reason = flight.get('predictedFailureReason', '') or flight.get('delayReason', '')
    
    if "Sick" in reason or "FDTL" in reason:
        replacement = await db.pilots.find_one({
            "status": "AVAILABLE",
            "currentDutyMinutes": {"$lt": 300},
            "base": flight.get("origin", "DEL")
        })
        if replacement:
            options.append({
                "id": "OPT_SWAP",
                "title": f"Assign Reserve: {replacement['name']}",
                "description": f"Ready at {replacement['base']}. Duty: {replacement['currentDutyMinutes']}m.",
                "action_type": "ASSIGN",
                "payload": {"flight_id": flight["_id"], "pilot_id": replacement["_id"]}
            })
    elif "Fog" in reason or "Weather" in reason or "Thunderstorm" in reason:
        options.append({
            "id": "OPT_HOLD",
            "title": "Hold Pattern (Wait 60m)",
            "description": "Wait for visibility.",
            "action_type": "DELAY_APPLY",
            "payload": {"flight_id": flight["_id"], "minutes": 60}
        })
        options.append({
            "id": "OPT_DIVERT",
            "title": "Divert to Alternate",
            "description": "Reroute.",
            "action_type": "CANCEL", 
            "payload": {"flight_id": flight["_id"]}
        })
    elif "Technical" in reason or "Hydraulic" in reason:
        options.append({
            "id": "OPT_FIX",
            "title": "Quick Repair (45m)",
            "description": "Minor fix.",
            "action_type": "DELAY_APPLY",
            "payload": {"flight_id": flight["_id"], "minutes": 45}
        })
        options.append({
            "id": "OPT_SWAP_AC",
            "title": "Swap Aircraft (90m)",
            "description": "Deploy spare.",
            "action_type": "DELAY_APPLY",
            "payload": {"flight_id": flight["_id"], "minutes": 90}
        })

    options.append({
        "id": "OPT_DELAY",
        "title": "Custom Manual Delay",
        "description": "Specify duration.",
        "action_type": "DELAY_MANUAL",
        "payload": {"flight_id": flight["_id"]}
    })
    
    if "Technical" not in reason and "Weather" not in reason:
        options.append({
            "id": "OPT_CANCEL",
            "title": "Cancel Flight",
            "description": "Operational constraints.",
            "action_type": "CANCEL",
            "payload": {"flight_id": flight["_id"]}
        })

    if req.mode == "MANUAL":
        return {"status": "OPTIONS_GENERATED", "options": options}
    
    best_option = None
    for opt in options:
        if opt['id'] == 'OPT_FIX': best_option = opt; break
        elif opt['id'] == 'OPT_SWAP': best_option = opt; break
        elif opt['id'] == 'OPT_HOLD': best_option = opt; break
        elif opt['id'] == 'OPT_SWAP_AC' and not best_option: best_option = opt; 
    
    if not best_option and options: best_option = options[0] 

    if best_option:
        LATEST_AGENT_LOGS.append(f"AGENT: Optimized Strategy: {best_option['title']}.")
        
        if best_option['action_type'] == 'ASSIGN':
            pid = best_option['payload']['pilot_id']
            pilot = await db.pilots.find_one({"_id": pid})
            await db.flights.update_one({"_id": flight["_id"]}, {
                "$set": {"status": "SCHEDULED", "assignedPilotId": pid, "Pilot_Name": pilot['name'], "predictedFailure": False}
            })
            LATEST_AGENT_LOGS.append(f"AUTO-RESOLVE: Assigned {pilot['name']}.")
            
        elif best_option['action_type'] == 'DELAY_APPLY':
            minutes = best_option['payload']['minutes']
            await db.flights.update_one({"_id": flight["_id"]}, {
                "$set": {"status": "DELAYED", "delayMinutes": minutes, "delayReason": best_option['title'], "predictedFailure": False}
            })
            LATEST_AGENT_LOGS.append(f"AUTO-RESOLVE: Applied {best_option['title']}.")
            f_doc = await db.flights.find_one({"_id": flight["_id"]})
            send_delay_email(flight["_id"], f_doc['origin'], f_doc['destination'], minutes, best_option['title'])

        elif best_option['action_type'] == 'CANCEL':
             await db.flights.update_one({"_id": flight["_id"]}, {"$set": {"status": "CANCELLED"}})
             LATEST_AGENT_LOGS.append(f"AUTO-RESOLVE: Flight Cancelled.")

    else:
        await db.flights.update_one({"_id": flight["_id"]}, {"$set": {"status": "CANCELLED"}})
        LATEST_AGENT_LOGS.append(f"AUTO-RESOLVE: Cancelled (No Options).")

    return {"status": "HEALED"}

@app.post("/resolve")
async def resolve(req: dict = Body(...)):
    opt = req['option']
    flight_id = opt['payload']['flight_id']
    
    if opt['action_type'] == 'CANCEL':
        await db.flights.update_one({"_id": flight_id}, {"$set": {"status": "CANCELLED"}})
        LATEST_AGENT_LOGS.append(f"MANUAL: Operator Cancelled {flight_id}.")
        
    elif opt['action_type'] == 'ASSIGN':
        pid = opt['payload']['pilot_id']
        pilot = await db.pilots.find_one({"_id": pid})
        await db.flights.update_one({"_id": flight_id}, {
            "$set": {"status": "SCHEDULED", "assignedPilotId": pid, "Pilot_Name": pilot['name'], "predictedFailure": False}
        })
        LATEST_AGENT_LOGS.append(f"MANUAL: Assigned {pilot['name']} to {flight_id}.")
        LATEST_AGENT_LOGS.append(f"NOTIFICATION: Roster Updated.")
        
    elif opt['action_type'] == 'DELAY_APPLY':
        minutes = opt['payload'].get('minutes', 60)
        title = opt.get('title', 'Manual Resolution')
        await db.flights.update_one({"_id": flight_id}, {
            "$set": {"status": "DELAYED", "delayMinutes": minutes, "delayReason": title, "predictedFailure": False}
        })
        LATEST_AGENT_LOGS.append(f"MANUAL: Applied {minutes}m Delay ({title}).")
        f_doc = await db.flights.find_one({"_id": flight_id})
        if f_doc: send_delay_email(flight_id, f_doc['origin'], f_doc['destination'], minutes, title)
        
    return {"status": "RESOLVED"}
